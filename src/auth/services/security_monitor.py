"""Security monitoring service for failed authentication tracking.

This service provides real-time monitoring of authentication attempts with:
- Failed login attempt tracking with configurable thresholds
- Account lockout detection and logging
- Brute force attempt pattern recognition
- Integration with existing AUTH-1 Cloudflare Access and AUTH-2 service token validation

Performance target: < 5ms monitoring overhead per authentication attempt
"""

import asyncio
from collections import defaultdict, deque
from dataclasses import dataclass, field
from datetime import UTC, datetime, timedelta
from typing import Any

from src.auth.database.security_events_postgres import SecurityEventsDatabase

from ..models import SecurityEventSeverity, SecurityEventType
from .security_logger import SecurityLogger


@dataclass
class MonitoringConfig:
    """Configuration for security monitoring."""

    # Failed authentication monitoring
    failed_attempts_threshold: int = 10  # Default: 10 attempts
    failed_attempts_window_minutes: int = 5  # Default: 5 minutes

    # Account lockout settings
    account_lockout_enabled: bool = True
    account_lockout_duration_minutes: int = 30

    # Brute force detection
    brute_force_threshold: int = 25  # Attempts before brute force alert
    brute_force_window_minutes: int = 10

    # IP-based tracking
    suspicious_ip_threshold: int = 50  # Failed attempts from single IP
    suspicious_ip_window_minutes: int = 15

    # Rate limiting for monitoring operations
    monitoring_rate_limit: int = 1000  # Max events per minute

    # Memory management
    max_tracking_entries: int = 10000
    cleanup_interval_minutes: int = 60


@dataclass
class FailedAttempt:
    """Represents a failed authentication attempt."""

    timestamp: datetime
    ip_address: str
    user_agent: str | None
    endpoint: str
    error_type: str
    user_id: str | None = None
    session_id: str | None = None


@dataclass
class SecurityAlert:
    """Represents a security alert generated by monitoring."""

    alert_type: str
    severity: SecurityEventSeverity
    user_id: str | None
    ip_address: str
    details: dict[str, Any]
    timestamp: datetime = field(default_factory=lambda: datetime.now(UTC))


class SecurityMonitor:
    """Real-time security monitor for authentication events."""

    def __init__(
        self,
        failed_attempts_threshold: int = 5,
        failed_attempts_window_minutes: int = 15,
        brute_force_threshold: int = 5,
        brute_force_window_minutes: int = 15,
        lockout_duration_minutes: int = 30,
        rate_limit_requests: int = 100,
        rate_limit_window_seconds: int = 60,
        account_lockout_enabled: bool = True,
        account_lockout_duration_minutes: int = 30,
        db=None,
        security_logger=None,
        alert_engine=None,
        config: MonitoringConfig | None = None,
    ) -> None:
        """Initialize security monitor.

        Args:
            failed_attempts_threshold: Threshold for failed attempts alerts
            failed_attempts_window_minutes: Time window for failed attempts
            brute_force_threshold: Threshold for brute force detection
            brute_force_window_minutes: Time window for brute force detection
            lockout_duration_minutes: Duration of account lockout
            rate_limit_requests: Max requests for rate limiting
            rate_limit_window_seconds: Time window for rate limiting
            account_lockout_enabled: Whether account lockout is enabled
            account_lockout_duration_minutes: Duration of account lockout (legacy)
            db: Database instance
            security_logger: Security logger instance
            alert_engine: Alert engine instance
            config: Monitoring configuration (uses defaults if None)
        """
        # Support both old config-based and new parameter-based initialization
        if config:
            self.config = config
            self.failed_attempts_threshold = config.failed_attempts_threshold
            self.failed_attempts_window_minutes = config.failed_attempts_window_minutes
            self.brute_force_threshold = config.brute_force_threshold
            self.brute_force_window_minutes = config.brute_force_window_minutes
            self.lockout_duration_minutes = config.account_lockout_duration_minutes
            self.account_lockout_enabled = config.account_lockout_enabled
            self.account_lockout_duration_minutes = config.account_lockout_duration_minutes
        else:
            self.failed_attempts_threshold = failed_attempts_threshold
            self.failed_attempts_window_minutes = failed_attempts_window_minutes
            self.brute_force_threshold = brute_force_threshold
            self.brute_force_window_minutes = brute_force_window_minutes
            self.lockout_duration_minutes = lockout_duration_minutes
            self.rate_limit_requests = rate_limit_requests
            self.rate_limit_window_seconds = rate_limit_window_seconds
            self.account_lockout_enabled = account_lockout_enabled
            self.account_lockout_duration_minutes = account_lockout_duration_minutes or lockout_duration_minutes
            # Create config from parameters
            self.config = MonitoringConfig(
                failed_attempts_threshold=failed_attempts_threshold,
                failed_attempts_window_minutes=failed_attempts_window_minutes,
                brute_force_threshold=brute_force_threshold,
                brute_force_window_minutes=brute_force_window_minutes,
                account_lockout_enabled=account_lockout_enabled,
                account_lockout_duration_minutes=self.account_lockout_duration_minutes,
            )

        # Initialize tracking structures with names expected by tests
        self._failed_attempts: dict[str, deque[FailedAttempt]] = defaultdict(deque)
        self._locked_accounts: dict[str, datetime] = {}
        self._rate_limit_tracker: dict[str, deque] = defaultdict(deque)

        # Also keep the original structures for backward compatibility
        self._failed_attempts_by_user = self._failed_attempts
        self._failed_attempts_by_ip: dict[str, deque[FailedAttempt]] = defaultdict(deque)
        self._suspicious_ips: set[str] = set()
        self._monitoring_rate_counter = deque()

        # Database and services
        if db is not None:
            self._db = db
        else:
            # Create a default database if none provided
            self._db = SecurityEventsDatabase()

        # Security logger for alert generation
        if security_logger is not None:
            self._security_logger = security_logger
        else:
            self._security_logger = SecurityLogger()

        # Alert engine
        if alert_engine is not None:
            self._alert_engine = alert_engine
        else:
            # Import here to avoid circular dependency
            from .alert_engine import AlertEngine

            self._alert_engine = AlertEngine()

        # Maintain compatibility
        self.security_logger = self._security_logger

        # Background cleanup task
        self._cleanup_task: asyncio.Task | None = None
        self._start_cleanup_task()

    async def initialize(self) -> None:
        """Initialize the security monitor and dependencies.

        This method ensures all dependencies are initialized and background tasks are running.
        It's idempotent and can be called multiple times safely.
        """
        # Initialize database
        await self._db.initialize()

        # Initialize security logger
        if hasattr(self._security_logger, "initialize"):
            await self._security_logger.initialize()

        # Initialize alert engine
        if hasattr(self._alert_engine, "initialize"):
            await self._alert_engine.initialize()

        # Restart cleanup task if needed
        if not self._cleanup_task or self._cleanup_task.done():
            self._start_cleanup_task()

    def _start_cleanup_task(self) -> None:
        """Start background cleanup task."""
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                self._cleanup_task = loop.create_task(self._periodic_cleanup())
        except RuntimeError:
            # No event loop running, cleanup will be handled manually
            pass

    async def _periodic_cleanup(self) -> None:
        """Periodic cleanup of expired entries."""
        while True:
            await asyncio.sleep(self.config.cleanup_interval_minutes * 60)
            await self._cleanup_expired_entries()

    async def _cleanup_expired_entries(self) -> None:
        """Clean up expired tracking entries to prevent memory growth."""
        current_time = datetime.now(UTC)
        cleanup_threshold = current_time - timedelta(hours=24)  # Keep 24 hours of data

        # Clean up failed attempts by user
        for user_id in list(self._failed_attempts_by_user.keys()):
            attempts = self._failed_attempts_by_user[user_id]
            while attempts and attempts[0].timestamp < cleanup_threshold:
                attempts.popleft()
            if not attempts:
                del self._failed_attempts_by_user[user_id]

        # Clean up failed attempts by IP
        for ip in list(self._failed_attempts_by_ip.keys()):
            attempts = self._failed_attempts_by_ip[ip]
            while attempts and attempts[0].timestamp < cleanup_threshold:
                attempts.popleft()
            if not attempts:
                del self._failed_attempts_by_ip[ip]

        # Clean up expired account locks
        expired_locks = [
            user_id
            for user_id, lock_time in self._locked_accounts.items()
            if current_time - lock_time > timedelta(minutes=self.config.account_lockout_duration_minutes)
        ]
        for user_id in expired_locks:
            del self._locked_accounts[user_id]

        # Clean up monitoring rate counter
        rate_threshold = current_time - timedelta(minutes=1)
        while self._monitoring_rate_counter and self._monitoring_rate_counter[0] < rate_threshold:
            self._monitoring_rate_counter.popleft()

    async def track_failed_authentication(
        self,
        user_id: str | None,
        ip_address: str,
        user_agent: str | None,
        endpoint: str,
        error_type: str,
        session_id: str | None = None,
    ) -> list[SecurityAlert]:
        """Track a failed authentication attempt and return any generated alerts.

        Args:
            user_id: User identifier (email or token name)
            ip_address: Client IP address
            user_agent: User agent string
            endpoint: Endpoint that was accessed
            error_type: Type of authentication error
            session_id: Session identifier if available

        Returns:
            List of security alerts generated
        """
        # Rate limiting check
        if not await self._check_monitoring_rate_limit():
            return []

        current_time = datetime.now(UTC)
        attempt = FailedAttempt(
            timestamp=current_time,
            ip_address=ip_address,
            user_agent=user_agent,
            endpoint=endpoint,
            error_type=error_type,
            user_id=user_id,
            session_id=session_id,
        )

        alerts = []

        # Track by user ID if available
        if user_id:
            self._failed_attempts_by_user[user_id].append(attempt)
            user_alerts = await self._check_user_thresholds(user_id)
            alerts.extend(user_alerts)

        # Track by IP address
        self._failed_attempts_by_ip[ip_address].append(attempt)
        ip_alerts = await self._check_ip_thresholds(ip_address)
        alerts.extend(ip_alerts)

        # Log all generated alerts
        for alert in alerts:
            await self._log_security_alert(alert)

        return alerts

    async def _check_monitoring_rate_limit(self) -> bool:
        """Check if monitoring operations are within rate limits."""
        current_time = datetime.now(UTC)

        # Clean up old entries
        cutoff_time = current_time - timedelta(minutes=1)
        while self._monitoring_rate_counter and self._monitoring_rate_counter[0] < cutoff_time:
            self._monitoring_rate_counter.popleft()

        # Check rate limit
        if len(self._monitoring_rate_counter) >= self.config.monitoring_rate_limit:
            return False

        self._monitoring_rate_counter.append(current_time)
        return True

    async def _check_user_thresholds(self, user_id: str) -> list[SecurityAlert]:
        """Check user-specific thresholds and generate alerts."""
        attempts = self._failed_attempts_by_user[user_id]
        current_time = datetime.now(UTC)
        alerts = []

        # Remove expired attempts
        threshold_time = current_time - timedelta(minutes=self.config.failed_attempts_window_minutes)
        while attempts and attempts[0].timestamp < threshold_time:
            attempts.popleft()

        recent_attempts = len(attempts)

        # Check failed attempts threshold
        if recent_attempts >= self.config.failed_attempts_threshold:
            # Check if already locked
            if user_id not in self._locked_accounts:
                if self.config.account_lockout_enabled:
                    self._locked_accounts[user_id] = current_time

                    alerts.append(
                        SecurityAlert(
                            alert_type="account_lockout",
                            severity=SecurityEventSeverity.WARNING,
                            user_id=user_id,
                            ip_address=attempts[-1].ip_address,
                            details={
                                "failed_attempts_count": recent_attempts,
                                "threshold": self.config.failed_attempts_threshold,
                                "window_minutes": self.config.failed_attempts_window_minutes,
                                "lockout_duration_minutes": self.config.account_lockout_duration_minutes,
                                "recent_endpoints": [attempt.endpoint for attempt in list(attempts)[-5:]],
                                "error_types": list(set(attempt.error_type for attempt in attempts)),
                            },
                        ),
                    )

        # Check brute force threshold
        brute_force_threshold_time = current_time - timedelta(minutes=self.config.brute_force_window_minutes)
        brute_force_attempts = [attempt for attempt in attempts if attempt.timestamp >= brute_force_threshold_time]

        if len(brute_force_attempts) >= self.config.brute_force_threshold:
            alerts.append(
                SecurityAlert(
                    alert_type="brute_force_attack",
                    severity=SecurityEventSeverity.CRITICAL,
                    user_id=user_id,
                    ip_address=attempts[-1].ip_address,
                    details={
                        "failed_attempts_count": len(brute_force_attempts),
                        "threshold": self.config.brute_force_threshold,
                        "window_minutes": self.config.brute_force_window_minutes,
                        "unique_ips": len(set(attempt.ip_address for attempt in brute_force_attempts)),
                        "unique_user_agents": len(
                            set(attempt.user_agent for attempt in brute_force_attempts if attempt.user_agent),
                        ),
                        "attack_pattern": "high_frequency_user_targeting",
                    },
                ),
            )

        return alerts

    async def _check_ip_thresholds(self, ip_address: str) -> list[SecurityAlert]:
        """Check IP-specific thresholds and generate alerts."""
        attempts = self._failed_attempts_by_ip[ip_address]
        current_time = datetime.now(UTC)
        alerts = []

        # Remove expired attempts
        threshold_time = current_time - timedelta(minutes=self.config.suspicious_ip_window_minutes)
        while attempts and attempts[0].timestamp < threshold_time:
            attempts.popleft()

        recent_attempts = len(attempts)

        # Check suspicious IP threshold
        if recent_attempts >= self.config.suspicious_ip_threshold:
            if ip_address not in self._suspicious_ips:
                self._suspicious_ips.add(ip_address)

                unique_users = set(attempt.user_id for attempt in attempts if attempt.user_id)
                unique_endpoints = set(attempt.endpoint for attempt in attempts)

                alerts.append(
                    SecurityAlert(
                        alert_type="suspicious_ip_activity",
                        severity=SecurityEventSeverity.WARNING,
                        user_id=None,
                        ip_address=ip_address,
                        details={
                            "failed_attempts_count": recent_attempts,
                            "threshold": self.config.suspicious_ip_threshold,
                            "window_minutes": self.config.suspicious_ip_window_minutes,
                            "unique_users_targeted": len(unique_users),
                            "unique_endpoints_accessed": len(unique_endpoints),
                            "user_targets": list(unique_users)[:10],  # Limit to prevent large payloads
                            "endpoint_targets": list(unique_endpoints),
                            "attack_pattern": (
                                "distributed_user_targeting" if len(unique_users) > 5 else "focused_attack"
                            ),
                        },
                    ),
                )

        return alerts

    async def _log_security_alert(self, alert: SecurityAlert) -> None:
        """Log security alert using the security logger."""
        event_type_mapping = {
            "account_lockout": SecurityEventType.ACCOUNT_LOCKOUT,
            "brute_force_attack": SecurityEventType.BRUTE_FORCE_ATTEMPT,
            "suspicious_ip_activity": SecurityEventType.SUSPICIOUS_ACTIVITY,
        }

        event_type = event_type_mapping.get(alert.alert_type, SecurityEventType.SECURITY_ALERT)

        await self.security_logger.log_event(
            event_type=event_type,
            severity=alert.severity,
            user_id=alert.user_id,
            ip_address=alert.ip_address,
            user_agent=None,  # Not available in alert context
            session_id=None,
            details={"alert_type": alert.alert_type, "alert_timestamp": alert.timestamp.isoformat(), **alert.details},
        )

    def is_account_locked(self, user_id: str) -> bool:
        """Check if an account is currently locked.

        Args:
            user_id: User identifier to check

        Returns:
            True if account is locked, False otherwise
        """
        if user_id not in self._locked_accounts:
            return False

        lock_time = self._locked_accounts[user_id]
        current_time = datetime.now(UTC)

        # Check if lock has expired
        if current_time - lock_time > timedelta(minutes=self.config.account_lockout_duration_minutes):
            del self._locked_accounts[user_id]
            return False

        return True

    def is_suspicious_ip(self, ip_address: str) -> bool:
        """Check if an IP address is marked as suspicious.

        Args:
            ip_address: IP address to check

        Returns:
            True if IP is suspicious, False otherwise
        """
        return ip_address in self._suspicious_ips

    async def get_monitoring_stats(self) -> dict[str, Any]:
        """Get current monitoring statistics.

        Returns:
            Dictionary with current monitoring statistics
        """
        current_time = datetime.now(UTC)

        # Calculate recent activity (last hour)
        recent_threshold = current_time - timedelta(hours=1)

        total_recent_failures = 0
        for attempts in self._failed_attempts_by_user.values():
            total_recent_failures += sum(1 for attempt in attempts if attempt.timestamp >= recent_threshold)

        return {
            "config": {
                "failed_attempts_threshold": self.config.failed_attempts_threshold,
                "failed_attempts_window_minutes": self.config.failed_attempts_window_minutes,
                "account_lockout_enabled": self.config.account_lockout_enabled,
                "brute_force_threshold": self.config.brute_force_threshold,
            },
            "current_state": {
                "tracked_users": len(self._failed_attempts_by_user),
                "tracked_ips": len(self._failed_attempts_by_ip),
                "locked_accounts": len(self._locked_accounts),
                "suspicious_ips": len(self._suspicious_ips),
                "recent_failures_last_hour": total_recent_failures,
            },
            "memory_usage": {
                "max_tracking_entries": self.config.max_tracking_entries,
                "current_user_entries": sum(len(attempts) for attempts in self._failed_attempts_by_user.values()),
                "current_ip_entries": sum(len(attempts) for attempts in self._failed_attempts_by_ip.values()),
            },
            "timestamp": current_time.isoformat(),
        }

    async def unlock_account(self, user_id: str) -> bool:
        """Manually unlock an account.

        Args:
            user_id: User identifier to unlock

        Returns:
            True if account was locked and is now unlocked, False otherwise
        """
        if user_id in self._locked_accounts:
            del self._locked_accounts[user_id]

            # Log the manual unlock event
            await self.security_logger.log_event(
                event_type=SecurityEventType.ACCOUNT_UNLOCK,
                severity=SecurityEventSeverity.INFO,
                user_id=user_id,
                ip_address="system",
                user_agent="security_monitor",
                session_id=None,
                details={"unlock_type": "manual", "unlock_timestamp": datetime.now(UTC).isoformat()},
            )

            return True

        return False

    async def process_security_event(self, event: Any) -> None:
        """Process a security event for monitoring.

        Args:
            event: Security event to process
        """
        # Track failed login attempts
        if hasattr(event, "event_type") and event.event_type == SecurityEventType.LOGIN_FAILURE:
            user_id = getattr(event, "user_id", None)
            ip_address = getattr(event, "ip_address", None)

            if user_id:
                await self.track_failed_authentication(
                    user_id=user_id,
                    ip_address=ip_address or "unknown",
                    user_agent=getattr(event, "user_agent", "unknown"),
                    event_type="login_failure",
                )

    async def record_failed_login(self, user_id: str, ip_address: str) -> None:
        """Record a failed login attempt.

        Args:
            user_id: User identifier
            ip_address: IP address of the attempt
        """
        await self.track_failed_authentication(
            user_id=user_id,
            ip_address=ip_address,
            user_agent="unknown",
            event_type="login_failure",
        )

    async def check_rate_limit(self, user_id: str, ip_address: str) -> bool:
        """Check if rate limit is exceeded.

        Args:
            user_id: User identifier
            ip_address: IP address

        Returns:
            True if rate limit is exceeded
        """
        # Check user rate limit
        if user_id in self._failed_attempts_by_user:
            user_attempts = self._failed_attempts_by_user[user_id]
            if len(user_attempts) >= self.config.failed_attempts_threshold:
                return True

        # Check IP rate limit
        if ip_address in self._failed_attempts_by_ip:
            ip_attempts = self._failed_attempts_by_ip[ip_address]
            if len(ip_attempts) >= self.config.brute_force_threshold:
                return True

        return False

    async def clear_failed_attempts(self, user_id: str) -> None:
        """Clear failed attempts for a user.

        Args:
            user_id: User identifier
        """
        if user_id in self._failed_attempts_by_user:
            del self._failed_attempts_by_user[user_id]

    async def detect_unusual_time(self, user_id: str, timestamp: datetime) -> bool:
        """Detect if login is at an unusual time.

        Args:
            user_id: User identifier
            timestamp: Login timestamp

        Returns:
            True if time is unusual for this user
        """
        # Simple check: Consider times between 2 AM and 5 AM as unusual
        hour = timestamp.hour
        return 2 <= hour <= 5

    async def detect_unusual_location(self, user_id: str, ip_address: str) -> bool:
        """Detect if login is from an unusual location.

        Args:
            user_id: User identifier
            ip_address: IP address

        Returns:
            True if location is unusual
        """
        # Check if IP is in suspicious list
        return ip_address in self._suspicious_ips

    async def detect_multiple_simultaneous_sessions(self, user_id: str) -> bool:
        """Detect multiple simultaneous sessions for a user.

        Args:
            user_id: User identifier

        Returns:
            True if multiple sessions detected
        """
        # This would need session tracking in a real implementation
        # For now, return False
        return False

    async def analyze_user_behavior_patterns(self, user_id: str) -> dict[str, Any]:
        """Analyze behavior patterns for a user.

        Args:
            user_id: User identifier

        Returns:
            Dictionary with behavior analysis
        """
        failed_attempts = self._failed_attempts_by_user.get(user_id, [])

        return {
            "total_failed_attempts": len(failed_attempts),
            "is_locked": user_id in self._locked_accounts,
            "recent_activity": len(
                [a for a in failed_attempts if (datetime.now(UTC) - a.timestamp).total_seconds() < 3600],
            ),
            "suspicious_activity": False,  # Would need more sophisticated analysis
        }

    async def get_security_metrics(self) -> dict[str, Any]:
        """Get comprehensive security metrics.

        Returns:
            Dictionary with security metrics
        """
        return await self.get_monitoring_stats()

    async def cleanup_expired_data(self) -> None:
        """Clean up expired monitoring data."""
        await self._cleanup_expired_entries()

    def __del__(self) -> None:
        """Cleanup when monitor is destroyed."""
        if self._cleanup_task and not self._cleanup_task.done():
            self._cleanup_task.cancel()
