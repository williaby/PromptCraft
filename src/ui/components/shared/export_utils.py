"""
Export utilities for PromptCraft-Hybrid interface.

This module provides functions for exporting content in various formats
with comprehensive metadata including model attribution, file sources,
and session information.
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


class ExportUtils:
    """
    Utility class for exporting content with metadata across all journeys.

    Features:
    - Multiple export formats (text, markdown, JSON)
    - Model attribution and cost tracking
    - File source attribution
    - Session metadata inclusion
    - Code snippet extraction and formatting
    """

    def __init__(self):
        self.export_formats = ["text", "markdown", "json"]

    def export_journey1_content(
        self,
        enhanced_prompt: str,
        create_breakdown: Dict[str, str],
        model_info: Dict[str, Any],
        file_sources: List[Dict[str, Any]],
        session_data: Dict[str, Any],
        format_type: str = "markdown",
    ) -> str:
        """
        Export Journey 1 content with full metadata.

        Args:
            enhanced_prompt: The enhanced prompt content
            create_breakdown: C.R.E.A.T.E. framework breakdown
            model_info: Model attribution information
            file_sources: List of source files used
            session_data: Session information
            format_type: Export format (text, markdown, json)

        Returns:
            Formatted export content
        """
        timestamp = datetime.now().isoformat()

        if format_type == "json":
            return self._export_as_json(
                {
                    "journey": "Journey 1: Smart Templates",
                    "timestamp": timestamp,
                    "enhanced_prompt": enhanced_prompt,
                    "create_breakdown": create_breakdown,
                    "model_info": model_info,
                    "file_sources": file_sources,
                    "session_data": session_data,
                }
            )

        elif format_type == "markdown":
            return self._export_as_markdown_j1(
                enhanced_prompt, create_breakdown, model_info, file_sources, session_data, timestamp
            )

        else:  # text format
            return self._export_as_text_j1(
                enhanced_prompt, create_breakdown, model_info, file_sources, session_data, timestamp
            )

    def _export_as_markdown_j1(
        self,
        enhanced_prompt: str,
        create_breakdown: Dict[str, str],
        model_info: Dict[str, Any],
        file_sources: List[Dict[str, Any]],
        session_data: Dict[str, Any],
        timestamp: str,
    ) -> str:
        """Export Journey 1 content as markdown."""

        # Build file sources section
        file_sources_md = ""
        if file_sources:
            file_sources_md = "\\n## 📄 Source Files\\n\\n"
            for file_info in file_sources:
                file_sources_md += f"- **{file_info.get('name', 'Unknown')}** ({file_info.get('type', 'unknown')})"
                if file_info.get("size"):
                    size_mb = file_info["size"] / (1024 * 1024)
                    file_sources_md += f" - {size_mb:.1f}MB"
                file_sources_md += "\\n"

        # Build C.R.E.A.T.E. breakdown
        create_md = """
## 📋 C.R.E.A.T.E. Framework Breakdown

### Context
{context}

### Request
{request}

### Examples
{examples}

### Augmentations
{augmentations}

### Tone & Format
{tone_format}

### Evaluation
{evaluation}
""".format(
            **create_breakdown
        )

        return f"""# Enhanced Prompt Export
*Generated by PromptCraft-Hybrid*

**Export Date:** {timestamp}
**Journey:** Journey 1: Smart Templates
**Model:** {model_info.get('model', 'Unknown')}
**Response Time:** {model_info.get('response_time', 'N/A')}s
**Cost:** ${model_info.get('cost', 0.0):.4f}

---

## ✨ Enhanced Prompt

{enhanced_prompt}

{create_md}

{file_sources_md}

---

## 🔍 Session Information

- **Session Cost:** ${session_data.get('total_cost', 0.0):.4f}
- **Requests:** {session_data.get('request_count', 0)}
- **Average Response Time:** {session_data.get('avg_response_time', 0.0):.2f}s

---

*Exported from PromptCraft-Hybrid | Generated with AI assistance*
"""

    def _export_as_text_j1(
        self,
        enhanced_prompt: str,
        create_breakdown: Dict[str, str],
        model_info: Dict[str, Any],
        file_sources: List[Dict[str, Any]],
        session_data: Dict[str, Any],
        timestamp: str,
    ) -> str:
        """Export Journey 1 content as plain text."""

        file_sources_txt = ""
        if file_sources:
            file_sources_txt = "\\n\\nSOURCE FILES USED:\\n"
            for file_info in file_sources:
                file_sources_txt += f"- {file_info.get('name', 'Unknown')} ({file_info.get('type', 'unknown')})\\n"

        return f"""ENHANCED PROMPT EXPORT
Generated by PromptCraft-Hybrid

Export Date: {timestamp}
Journey: Journey 1: Smart Templates
Model: {model_info.get('model', 'Unknown')}
Response Time: {model_info.get('response_time', 'N/A')}s
Cost: ${model_info.get('cost', 0.0):.4f}

{"="*50}

ENHANCED PROMPT:

{enhanced_prompt}

{"="*50}

C.R.E.A.T.E. FRAMEWORK BREAKDOWN:

CONTEXT:
{create_breakdown.get('context', 'N/A')}

REQUEST:
{create_breakdown.get('request', 'N/A')}

EXAMPLES:
{create_breakdown.get('examples', 'N/A')}

AUGMENTATIONS:
{create_breakdown.get('augmentations', 'N/A')}

TONE & FORMAT:
{create_breakdown.get('tone_format', 'N/A')}

EVALUATION:
{create_breakdown.get('evaluation', 'N/A')}

{file_sources_txt}

{"="*50}

SESSION INFORMATION:
- Session Cost: ${session_data.get('total_cost', 0.0):.4f}
- Requests: {session_data.get('request_count', 0)}
- Average Response Time: {session_data.get('avg_response_time', 0.0):.2f}s

Exported from PromptCraft-Hybrid | Generated with AI assistance
"""

    def _export_as_json(self, data: Dict[str, Any]) -> str:
        """Export content as JSON with proper formatting."""
        try:
            return json.dumps(data, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"Error exporting as JSON: {e}")
            return json.dumps({"error": f"Export failed: {e}"}, indent=2)

    def extract_code_blocks(self, content: str) -> List[Dict[str, str]]:
        """
        Extract code blocks from content with enhanced detection.

        Args:
            content: Content to extract code blocks from

        Returns:
            List of code block dictionaries with language and content
        """
        import re

        # Pattern to match code blocks with optional language specification
        pattern = r"```(?:([\w-]+))?\n([\s\S]*?)```"
        matches = re.findall(pattern, content)

        code_blocks = []
        for i, (language, code) in enumerate(matches):
            code_content = code.strip()
            lines = code_content.split("\\n")

            # Enhanced language detection
            detected_language = language or self._detect_language(code_content)

            # Extract any inline comments or documentation
            comments = self._extract_comments(code_content, detected_language)

            code_blocks.append(
                {
                    "id": i + 1,
                    "language": detected_language,
                    "content": code_content,
                    "line_count": len(lines),
                    "char_count": len(code_content),
                    "comments": comments,
                    "has_functions": self._has_functions(code_content, detected_language),
                    "complexity": self._assess_complexity(code_content),
                    "preview": lines[0][:50] + "..." if lines else "",
                }
            )

        return code_blocks

    def _detect_language(self, code: str) -> str:
        """Detect programming language from code content."""
        import re

        # Simple language detection based on common patterns
        if re.search(r"def\s+\w+\s*\(", code):
            return "python"
        elif re.search(r"function\s+\w+\s*\(", code):
            return "javascript"
        elif re.search(r"class\s+\w+\s*{", code):
            return "java"
        elif re.search(r"#include\s*<", code):
            return "cpp"
        elif re.search(r"SELECT\s+.*FROM", code, re.IGNORECASE):
            return "sql"
        elif re.search(r"<html|<div|<p>", code, re.IGNORECASE):
            return "html"
        elif re.search(r'{\s*["\']?\w+["\']?\s*:', code):
            return "json"
        elif re.search(r"---\n", code):
            return "yaml"
        else:
            return "text"

    def _extract_comments(self, code: str, language: str) -> List[str]:
        """Extract comments from code based on language."""
        import re

        comments = []

        if language == "python":
            # Python comments
            comments.extend(re.findall(r"#\s*(.+)", code))
            comments.extend(re.findall(r'"""([\s\S]*?)"""', code))
        elif language in ["javascript", "java", "cpp"]:
            # C-style comments
            comments.extend(re.findall(r"//\s*(.+)", code))
            comments.extend(re.findall(r"/\*([\s\S]*?)\*/", code))
        elif language == "html":
            # HTML comments
            comments.extend(re.findall(r"<!--([\s\S]*?)-->", code))

        return [comment.strip() for comment in comments if comment.strip()]

    def _has_functions(self, code: str, language: str) -> bool:
        """Check if code contains function definitions."""
        import re

        if language == "python":
            return bool(re.search(r"def\s+\w+\s*\(", code))
        elif language == "javascript":
            return bool(re.search(r"function\s+\w+\s*\(", code))
        elif language in ["java", "cpp"]:
            return bool(re.search(r"\w+\s+\w+\s*\([^)]*\)\s*{", code))
        return False

    def _assess_complexity(self, code: str) -> str:
        """Assess code complexity."""
        lines = len(code.split("\\n"))
        if lines < 5:
            return "simple"
        elif lines < 20:
            return "moderate"
        else:
            return "complex"

    def format_code_blocks_for_export(self, code_blocks: List[Dict[str, str]]) -> str:
        """
        Format code blocks for export with enhanced metadata.

        Args:
            code_blocks: List of code block dictionaries

        Returns:
            Formatted code blocks for export
        """
        if not code_blocks:
            return "No code blocks found."

        # Summary header
        total_lines = sum(block.get("line_count", 0) for block in code_blocks)
        languages = list(set(block.get("language", "text") for block in code_blocks))

        export_content = f"""CODE BLOCKS EXPORT
==================
• Total blocks: {len(code_blocks)}
• Total lines: {total_lines}
• Languages: {', '.join(languages)}
• Extracted: {len([b for b in code_blocks if b.get('has_functions')])} blocks with functions

"""

        for block in code_blocks:
            # Enhanced block header
            complexity = block.get("complexity", "unknown")
            has_functions = block.get("has_functions", False)
            comments_count = len(block.get("comments", []))

            export_content += f"{'='*60}\n"
            export_content += f"📄 Block {block['id']}: {block.get('language', 'text').upper()}\n"
            export_content += f"{'='*60}\n"
            export_content += f"• Lines: {block.get('line_count', 0)}\n"
            export_content += f"• Characters: {block.get('char_count', 0)}\n"
            export_content += f"• Complexity: {complexity}\n"
            export_content += f"• Functions: {'Yes' if has_functions else 'No'}\n"
            export_content += f"• Comments: {comments_count}\n"

            if block.get("preview"):
                export_content += f"• Preview: {block['preview']}\n"

            export_content += f"\n{'-'*40}\n"
            export_content += f"CODE:\n"
            export_content += f"{'-'*40}\n"
            export_content += block["content"]
            export_content += "\n\n"

            # Include comments if available
            if block.get("comments"):
                export_content += f"{'-'*40}\n"
                export_content += f"COMMENTS:\n"
                export_content += f"{'-'*40}\n"
                for comment in block["comments"]:
                    export_content += f"• {comment}\n"
                export_content += "\n"

        return export_content

    def copy_code_as_markdown(self, code_blocks: List[Dict[str, str]]) -> str:
        """
        Format code blocks as markdown for copying with enhanced metadata.

        Args:
            code_blocks: List of code block dictionaries

        Returns:
            Markdown formatted code blocks
        """
        if not code_blocks:
            return "No code blocks found."

        # Summary header
        total_lines = sum(block.get("line_count", 0) for block in code_blocks)
        languages = list(set(block.get("language", "text") for block in code_blocks))

        markdown_content = f"""# Code Blocks Export

**Summary:**
- Total blocks: {len(code_blocks)}
- Total lines: {total_lines}
- Languages: {', '.join(languages)}

---

"""

        for block in code_blocks:
            # Enhanced block header with metadata
            complexity = block.get("complexity", "unknown")
            has_functions = block.get("has_functions", False)
            comments_count = len(block.get("comments", []))

            markdown_content += f"## Block {block['id']}: {block.get('language', 'text').title()}\n\n"

            # Metadata table
            markdown_content += f"""**Metadata:**
- Lines: {block.get('line_count', 0)}
- Characters: {block.get('char_count', 0)}
- Complexity: {complexity}
- Contains functions: {'Yes' if has_functions else 'No'}
- Comments: {comments_count}

"""

            # Add comments if available
            if block.get("comments"):
                markdown_content += f"**Comments:**\n"
                for comment in block["comments"]:
                    markdown_content += f"- {comment}\n"
                markdown_content += "\n"

            # Code block
            markdown_content += f"```{block.get('language', 'text')}\n{block['content']}\n```\n\n"

            # Separator
            markdown_content += "---\n\n"

        return markdown_content.strip()

    def prepare_download_file(self, content: str, filename: str, format_type: str = "txt") -> str:
        """
        Prepare content for download.

        Args:
            content: Content to prepare for download
            filename: Base filename (without extension)
            format_type: File format (txt, md, json)

        Returns:
            Formatted filename for download
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        clean_filename = "".join(c for c in filename if c.isalnum() or c in (" ", "-", "_")).rstrip()

        return f"{clean_filename}_{timestamp}.{format_type}"
